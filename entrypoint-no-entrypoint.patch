--- a/ziskos/entrypoint/src/lib.rs
+++ b/ziskos/entrypoint/src/lib.rs
@@ -110,6 +110,7 @@ mod ziskos {
     use crate::ziskos_definitions::ziskos_config::*;
     use core::arch::asm;

+    #[cfg(not(feature = "no_entrypoint"))]
     #[no_mangle]
     #[link_section = ".text.init"]
     unsafe extern "C" fn _start() -> ! {
@@ -163,6 +164,7 @@ mod ziskos {
         getrandom::register_custom_getrandom!(zkvm_getrandom);
     }

+    #[cfg(not(feature = "no_entrypoint"))]
     #[no_mangle]
     unsafe extern "C" fn _zisk_main() {
         {
@@ -242,45 +244,15 @@ mod ziskos {

     #[no_mangle]
     pub unsafe extern "C" fn sys_alloc_aligned(bytes: usize, align: usize) -> *mut u8 {
-        use core::arch::asm;
-        let heap_bottom: usize;
-        // UNSAFE: This is fine, just loading some constants.
-        unsafe {
-            // using inline assembly is easier to access linker constants
-            asm!(
-              "la {heap_bottom}, _kernel_heap_bottom",
-              heap_bottom = out(reg) heap_bottom,
-              options(nomem)
-            )
-        };
-
-        // Pointer to next heap address to use, or 0 if the heap has not yet been
-        // initialized.
-        static mut HEAP_POS: usize = 0;
-
-        // SAFETY: Single threaded, so nothing else can touch this while we're working.
-        let mut heap_pos = unsafe { HEAP_POS };
-
-        if heap_pos == 0 {
-            heap_pos = heap_bottom;
+        extern "C" {
+            fn malloc(size: usize) -> *mut u8;
         }

-        let offset = heap_pos & (align - 1);
-        if offset != 0 {
-            heap_pos += align - offset;
-        }
-
-        let ptr = heap_pos as *mut u8;
-        heap_pos += bytes;
-
-        // Check to make sure heap doesn't collide with SYSTEM memory.
-        //if SYSTEM_START < heap_pos {
-        //    panic!();
-        // }
-
-        unsafe { HEAP_POS = heap_pos };
-
-        ptr
+        // For simplicity, just use malloc and ignore alignment for now
+        // In a production system, you'd want to use posix_memalign or similar
+        unsafe { malloc(bytes) }
     }
+    #[cfg(not(feature = "no_entrypoint"))]
     core::arch::global_asm!(include_str!("dma/memcpy.s"));
+    #[cfg(not(feature = "no_entrypoint"))]
     core::arch::global_asm!(include_str!("dma/memmove.s"));
     // core::arch::global_asm!(include_str!("dma/memcmp.s"));
 }
